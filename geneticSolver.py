import copy
import random

from bitarray import bitarray, util
from deap import base, creator, tools, algorithms
from deap.tools import HallOfFame

from inputs import *


# allowed rotations: {0, 90, 180, 270}

# converts the bitarray back to rotations
# since there are 4 options for a rotation, each rotation takes of 2 bits
def calculate_rotations(indv: bitarray) -> List[int]:
    rotations = []
    for i in range(0, len(indv), 2):
        rotations.append(util.ba2int(indv[i: i + 2]) * 90)
    return rotations


# this updates each axis in the list based on the rotations about those axis
def update_axis(axis: List[Axis], rotations: List[int]) -> List[Axis]:
    quaternions = [Quaternion(axis=axis[0], degrees=rotations[0])]
    for a in range(1, len(axis)):
        new_q = Quaternion(axis=axis[a], degrees=rotations[a])
        quaternions.append(quaternions[-1] * new_q)
    new_axis = [axis[0]]
    for a in range(1, len(axis)):
        # round to the nearest int, since the quaternion rotation often gives floats that are really close to zero or 1
        new_ax = tuple(round(x) for x in quaternions[a - 1].rotate((axis[a])))
        new_axis.append(new_ax)
    return new_axis


# this returns a set containing the points adjacent to this point
def get_adjacent(p: Point) -> set[Point]:
    return {
        (p[0] + 1, p[1], p[2]),
        (p[0] - 1, p[1], p[2]),
        (p[0], p[1] + 1, p[2]),
        (p[0], p[1] - 1, p[2]),
        (p[0], p[1], p[2] + 1),
        (p[0], p[1], p[2] - 1),
    }


# counts the points that are adjacent to each other
# if a point collides with another point, anything adjacent isn't counted
def count_adjacent_and_collisions(axis: List[Axis]) -> int:
    point = (0, 0, 0)
    points = {point}
    adjacent = 0
    collisions = 0
    for a in axis:
        point = calculate_next_cube_point(point, a)
        adjacent_points = get_adjacent(point)
        intersection = len(adjacent_points.intersection(points))
        if point in points:
            collisions += 1
        else:
            adjacent += intersection
            points.add(point)
    return adjacent, collisions


# this is some weirdness needed to make bitarray deepcopy correctly with the genetic algorithm library
# I didn't write this, I just copied to code they did for python's array.array
class _bitarray(bitarray):
    @staticmethod
    def __new__(cls, seq=()):
        return super(_bitarray, cls).__new__(cls, seq)

    def __deepcopy__(self, memo):
        """Overrides the deepcopy from bitarray that does not copy
        the object's attributes and class type.
        """
        cls = self.__class__
        copy_ = cls.__new__(cls, self)
        memo[id(self)] = copy_
        copy_.__dict__.update(copy.deepcopy(self.__dict__, memo))
        return copy_

    def __reduce__(self):
        return self.__class__, (list(self),), self.__dict__


# again, more weirdness needed for the library. this gets used to initialize something to all zero
def zero():
    return 0


# this evaluates an individual generated by the genetic algorithm
# the components of the score are the number of adjacent cubes, number of collisions, and the number of rotations
# we want to maximize adjacent cubes but minimize collisions,
# and also minimize rotations to make the solution easier to do in real-life
def evaluate(individual):
    rotations = calculate_rotations(individual)  # convert bitarray to list of rotations (0, 90, 180, 270 degrees)
    new_axis = update_axis(individual.axis, rotations)
    adj, col = count_adjacent_and_collisions(new_axis)
    non_zero = sum(1 for r in rotations if r != 0)
    return adj, col, non_zero


if __name__ == '__main__':
    # weights needed to maximize adjacent squares, minimize collisions, minimize total rotations
    creator.create("FitnessMulti", base.Fitness, weights=(1.0, -1.0, -0.1))
    # an "Individual" is our list of rotations (0, 90, 180, 270)
    creator.class_replacers[bitarray] = _bitarray
    creator.create("Individual", bitarray, fitness=creator.FitnessMulti, axis=block_axis)

    IND_SIZE = len(block_axis) * 2
    toolbox = base.Toolbox()
    toolbox.register("attr_bit", random.choice, [0, 1])
    toolbox.register("individual_random", tools.initRepeat, creator.Individual, toolbox.attr_bit, n=IND_SIZE)
    toolbox.register("individual_zero", tools.initRepeat, creator.Individual, zero, n=IND_SIZE)
    # makes a population made of random initial rotations and zero initial rotations
    toolbox.register("population", tools.initCycle, list, (toolbox.individual_random, toolbox.individual_zero))

    # required evolution operators
    # I have a very basic understanding of how the evolution works,
    # this stuff I copied from their example
    toolbox.register("mate", tools.cxTwoPoint)  # or cxTwoPoint, cxUniform(indpb=float)
    toolbox.register("mutate", tools.mutFlipBit, indpb=0.1)
    toolbox.register("select", tools.selTournament, tournsize=3)  # many selection options
    toolbox.register("evaluate", evaluate)

    fame = HallOfFame(maxsize=10)
    pop, logbook = algorithms.eaSimple(population=toolbox.population(n=200), toolbox=toolbox, cxpb=0.2, mutpb=0.2,
                                       ngen=1000, halloffame=fame)
    best_rotations = fame[0]
    axis = update_axis(fame[0].axis, fame[0])
    print('best rotation sequence adjacent, collisions, total rotations: ' + str(fame[0].fitness.values))
    print('sequence of rotations: ' + str(calculate_rotations(best_rotations)))
    print('points of the cube: ' + str(calculate_points(axis)))
